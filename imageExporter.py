# -*- coding: utf-8 -*-
"""ClimateEye.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qZmq6Dw5RPgq_cm0GG1VMTh5P9g1jE6C
"""

from pydoc import resolve
import ee
import pandas as pd
import numpy as np
import time
from geetools import batch
from tqdm import tqdm
from argparse import ArgumentParser
import requests
import math
import logging
import multiprocessing
import requests
import shutil
#from retry import retry
import multiprocessing
import os

# # Trigger the authentication flow.
# ee.Authenticate()

# # Initialize the library.
# ##ee.Initialize()
# ##high volume API
# ee.Initialize(opt_url='https://earthengine-highvolume.googleapis.com')


def boundingBox(lat, lon, size, res):
    earth_radius = 6371000
    angular_distance = math.degrees(0.5 * ((size * res) / earth_radius))
    osLat = angular_distance
    osLon = angular_distance  # / math.cos(math.radians(lat))
    xMin = lon - osLon
    xMax = lon + osLon
    yMin = lat - osLat
    yMax = lat + osLat
    return xMin, xMax, yMin, yMax


start_date = '2017-01-01'
end_date = '2018-01-01'
RGB_VIZ = {'bands': ['B4', 'B3', 'B2'], 'min': 0, 'max': 0.4}
crs = 'EPSG:3857'
crs2 = 'EPSG:4326'
fileFormat = 'GeoTIFF'
cloud_filter = 10

# Attempt to use logging
# Not working yet
logger = logging.getLogger('my_logger')
logging.basicConfig(filename='file.log',
                    filemode='a')


def extract_images(filepath, dataset, res, start, end,
                   bands, height, width, output_dir):
    landsat = ee.ImageCollection("LANDSAT/LC08/C02/T1_TOA")
    RGB_VIZ = {'min': 0, 'max': 0.4, 'bands': [
        'B4', 'B3', 'B2']} if dataset == landsat else {}
    crs = 'EPSG:3857'
    crs2 = 'EPSG:4326'
    fileFormat = 'GeoTIFF'

    coords = pd.read_csv(filepath)
    start_time_recorded = False

    for i in tqdm(range(len(coords))):
        coord = ((coords["lat"][i], coords["lon"][i]))
        lat = coord[0]
        lon = coord[1]
        description = f"image_{lat}_{lon}"
        xMin, xMax, yMin, yMax = boundingBox(lat, lon, height, res)
        geometry = ee.Geometry.Rectangle([[xMin, yMin], [xMax, yMax]])
        RGB = ['B4', 'B3', 'B2'] if dataset == landsat else ['R', 'G', 'B']
        filtered = dataset.filterDate(start, end).filterBounds(geometry).filter(
            ee.Filter.lt('CLOUD_COVER', cloud_filter)).select(bands)
        try:
            image = filtered.median().clip(geometry).select(RGB)
            # LANDSAT SPECIFIC!! MUST CHANGE MIN, MAX PARAMS DEPENDING ON MEANING IN EACH DATASET
            if dataset == landsat:
                img = image.visualize(bands=RGB, min=0, max=0.5)

            export_links = True

            if export_links == True:
                url = image.getDownloadUrl({
                    'description': description,
                    'region': geometry,
                    'fileNamePrefix': description,
                    'crs': crs,
                    'fileFormat': fileFormat,
                    'bands': RGB,
                    'region': geometry,
                    'format': 'GEO_TIFF',
                    # 'scale': res,
                    'dimensions': [height, width]
                })

        # save image to disk!
            if not start_time_recorded:
                start_time_recorded = True
                export_start_time = time.time()
            response = requests.get(url)
            with open(os.path.join('/home/sl636/climateEye/exported_images', f'{description}.tif'), 'wb') as fd:
                fd.write(response.content)

        except ee.EEException as e:
            # change below print to log
            print(f"\nimage at {(lat, lon)} missing one or more RGB bands")
            pass

    return export_start_time


if __name__ == "__main__":
    try:
        ee.Initialize(opt_url='https://earthengine-highvolume.googleapis.com')
    except:
        ee.Authenticate()
        ee.Initialize(opt_url='https://earthengine-highvolume.googleapis.com')
    parser = ArgumentParser()
    parser.add_argument("-f", "--filepath",
                        help="path to coordinates csv file",  type=str)
    parser.add_argument("-d", "--dataset", help="dataset to pull images from",
                        default=ee.ImageCollection("LANDSAT/LC08/C02/T1_TOA"), type=ee.ImageCollection)
    parser.add_argument(
        "-r", "--resolution", help='resolution of passed dataset (in m/px)', default=30, type=int)
    parser.add_argument(
        "-s", "--start_date", help="start date for getting images", default="'2017-01-01'", type=str)
    parser.add_argument(
        "-e", "--end_date", help="end date for getting images", default="'2018-01-01'", type=str)
    parser.add_argument("-b", "--bands", help="list of desired bands",
                        default=['B2', 'B3', 'B4', 'B5'], type=list)
    parser.add_argument(
        "-he", "--height", help="height of output images (in px)", default=512, type=int)
    parser.add_argument(
        "-w", "--width", help="width of output images (in px)", default=512, type=int)
    parser.add_argument(
        "-o", "--output_dir", help="path to output directory", default="data/", type=str)

    args = parser.parse_args()
    if not os.path.exists(args.output_dir):
        os.makedirs(args.output_dir)
        pass

    export_start_time = extract_images(filepath=args.filepath,
                                       dataset=args.dataset,
                                       res=args.res,
                                       start=args.start_date,
                                       end=args.end_date,
                                       bands=args.bands,
                                       height=args.height,
                                       width=args.width,
                                       output_dir=args.output_dir)
    export_finish_time = time.time()
    duration = export_finish_time - export_start_time
    print(f'Export complete! Total duration: {duration} s')
